System waste_service_prototipo

Request depositRequest : depositRequest(MAT, QNT)
Reply replyDeposit : replyDeposit(RESPONSE)
Dispatch pickedUp : pickedUp(MAT, QNT)

Request storageAsk : storageAsk(_)
Reply storageAt : storageAt(QNT)
Event storageUpdate : storageUpdate(MAT, QNT)

Reply doneDeposit : doneDeposit(MAT, QNT)

Event tStatus : tStatus(STATE, POSDATA)

Dispatch storageDeposit : storageDeposit(QNT)

Dispatch ledStatus : ledStatus(STATUS)

Event trolleyStop : trolleyStop(_)
Event trolleyResume : trolleyResume(_)

Context ctxwasteservice ip [host="localhost" port=8050]

// Non sarà probabilmente attore nella versione finale,
// rappresentato così per semplicità nel sistema
QActor camion context ctxwasteservice {
	[#
		var Allowed = false
	#]
	
	State init initial {
		
	}
	Goto req
	
	State waitArrival {
		[# var DelayTime : kotlin.Long = kotlin.random.Random.nextLong(7000, 10000) #]
		delayVar DelayTime
	}
	Goto req
	
	State req {
		[#
			var Material = if (kotlin.random.Random.nextFloat() > 0.5) "glass" else "paper"
			var Quantity = kotlin.random.Random.nextInt(10, 30)	
		#]
		println ("Truck with $Material in amount $Quantity arrived")
		request wasteservice -m depositRequest : depositRequest($Material, $Quantity)
	}
	Transition t1 whenReply replyDeposit -> handleReplyDeposit
	
		State handleReplyDeposit {
		onMsg(replyDeposit : replyDeposit(ALLOW)) {
			
			if [# "loadaccept" != payloadArg(0) #] {
				println("\tTruck left (denied)")
				[# Allowed = false #]
			} else {
				[# Allowed = true #]
				println("\tTruck left (allowed)")
			}
		}
	}
	Goto waitArrival if [# !Allowed #] else waitPickup
	
	State waitPickup {
		
	} 
	Transition t3 whenMsg pickedUp -> finish
	
	State finish {
		println("\tTruck left (done)")
	}
	Goto waitArrival
}

QActor wasteservice context ctxwasteservice {
[#
  var TrolleyOut = false
  var OnTrolleyGlass = 0.0
  var OnTrolleyPaper = 0.0
  var CurrentRequestMaterial = ""
  var CurrentRequestQuantity = 0.0
  var CurrentRequestCheck = 0.0
  var FulfillRequestFlag = false
#]  
	State init initial {
		
	}
	Goto idle
	
	State idle {
		printCurrentMessage
	}
	Transition tIdle whenRequest depositRequest -> askStorage
	
	State askStorage {
		printCurrentMessage
		onMsg( depositRequest : depositRequest(MAT, QNT) ){
  			[# 
  				CurrentRequestMaterial = payloadArg(0)
  				CurrentRequestQuantity = payloadArg(1).toDouble()
  				CurrentRequestCheck = CurrentRequestQuantity
			#]
  			
  			if [# CurrentRequestMaterial == "glass" #] {
  				request storage_glass -m storageAsk : storageAsk(_)
  				[# CurrentRequestCheck += OnTrolleyGlass #]
  			} else {
  				request storage_paper -m storageAsk : storageAsk(_)
  				[# CurrentRequestCheck += OnTrolleyPaper #]
  			}
		}
	}
	Transition tAskStorage whenReply storageAt -> handleRequest 
	
	State handleRequest {
		printCurrentMessage
		// Nota: non serve sapere pi�2 da che storage arriva
		onMsg( storageAt : storageAt(QNT) ) {
			if [# CurrentRequestCheck <= payloadArg(0).toDouble() #] {
				replyTo depositRequest with replyDeposit : replyDeposit(loadaccept)
			} else {
				replyTo depositRequest with replyDeposit : replyDeposit(loadrejected)
			}
		}
	}
	Goto fulfillRequest if [# FulfillRequestFlag #] else idle 
	
	State fulfillRequest {
		printCurrentMessage
	}
	Goto sendTrolley if [# !TrolleyOut #] else waitForTrolley
	
	State waitForTrolley {
		printCurrentMessage
	}
	Transition tWaitForTrolley whenReply doneDeposit -> sendTrolley 
	
	State sendTrolley {
		printCurrentMessage
		
		forward camion -m pickedUp : pickedUp($CurrentRequestMaterial, $CurrentRequestQuantity)
		request trolley -m depositRequest : depositRequest($CurrentRequestMaterial, $CurrentRequestQuantity)
		
		if [# CurrentRequestMaterial == "glass" #] {
			[# OnTrolleyGlass = CurrentRequestQuantity #]
		} else {
			[# OnTrolleyPaper = CurrentRequestQuantity #]
		}
		
		[#
		TrolleyOut = true
		CurrentRequestQuantity = 0.0
		CurrentRequestMaterial = ""
		#]
	}
	Transition tSendTrolley whenReply doneDeposit -> trolleyBack
							whenRequest depositRequest -> askStorage
							
	State trolleyBack {
		printCurrentMessage
		[# 
			TrolleyOut = false
			OnTrolleyGlass = 0.0
			OnTrolleyPaper = 0.0
		#]
	}
	Goto idle
}

QActor trolley context ctxwasteservice {
	[#
		var TrolleyState = ""
		var Interrupt = false
		var CarryType = ""
		var CarryAmount = 0.0
		var Position = 0.0	
		var MaxPos = kotlin.random.Random.nextLong(1, 8)
	#]
	
	State init initial {
		
	}
	Goto idle
	
	State idle {
		[# TrolleyState = "idle" #]
		printCurrentMessage
		emit tStatus : tStatus(home, $Position)
	}
	Transition tIdle whenEvent trolleyStop -> handleStop
					 whenRequest depositRequest -> startMoveDeposit
	
	State startMoveDeposit {
		[# TrolleyState = "startMoveDeposit" #]
		printCurrentMessage
		
		emit tStatus : tStatus(moving, $Position)
		
		onMsg(depositRequest: depositRequest(MAT, QNT)) {
			[# 
  				CarryType = payloadArg(0)
  				CarryAmount = payloadArg(1).toDouble()
			#]
		}
	}
	Transition twaitDepositEnd whenTime 0 -> waitDepositEnd
							   whenEvent trolleyStop -> handleStop
	
	State waitDepositEnd {
		[# TrolleyState = "waitDepositEnd" #]
		[# Position += 1.0 #]
		printCurrentMessage
		println("\tCurrent Position is: $Position")
		emit tStatus : tStatus(moving, $Position)
		delay 1000
	}
	Transition tDepositEnd whenTime 0 -> depositEndCheck
						   whenEvent trolleyStop -> handleStop	
						   
	State depositEndCheck{}
	Goto depositEnd if [# Position >= MaxPos #] else waitDepositEnd
	
	State depositEnd {
		printCurrentMessage
		[# TrolleyState = "depositEnd" #]
		
		emit tStatus : tStatus(stopped, $Position)
		
		if [# CarryType == "glass" #] {
			forward storage_glass -m storageDeposit : storageDeposit($CarryAmount)
		} else {
			forward storage_paper -m storageDeposit : storageDeposit($CarryAmount)
		}
	}
	Transition tWaitReturnedIndoor whenTime 0 -> waitReturnedIndoor
							       whenEvent trolleyStop -> handleStop	
	
	State waitReturnedIndoor {
		[# TrolleyState = "waitReturnedIndoor" #]
		[#
			Position -= 1.0	
		#]
		printCurrentMessage
				println("\tGoing back. Current Position is: $Position")
		
		emit tStatus : tStatus(moving, $Position)
		delay 1000
	}
	Transition tReturnedIndoor whenTime 0 -> checkReturnedIndoor
							   whenEvent trolleyStop -> handleStop	
	State checkReturnedIndoor{}
	Goto returnedIndoor if [# Position <= 0 #] else waitReturnedIndoor
	
	State returnedIndoor {
		[# TrolleyState = "returnedIndoor" #]
		printCurrentMessage
		
		emit tStatus : tStatus(home, $Position)
		
		replyTo depositRequest with doneDeposit : doneDeposit($CarryType, $CarryAmount)
	}
	Transition tIdle whenTime 0 -> idle
					 whenEvent trolleyStop -> handleStop
	
	State handleStop {
		printCurrentMessage
		[# Interrupt = true #]
	}
	Goto waitSonar
	
	
	State handleResume {
		printCurrentMessage
		[# Interrupt = false #]
	}
	Goto startMoveDeposit if [# TrolleyState == "idle" #] else checkResume_startMoveDeposit
	State checkResume_startMoveDeposit{}
	Goto waitDepositEnd if [# TrolleyState == "startMoveDeposit" #] else checkResume_waitDepositEnd
	State checkResume_waitDepositEnd{}
	Goto depositEndCheck if [# TrolleyState == "waitDepositEnd" #] else checkResume_depositEnd
	State checkResume_depositEnd{}
	Goto waitReturnedIndoor if [# TrolleyState == "depositEnd" #] else checkResume_waitReturnedIndoor
	State checkResume_waitReturnedIndoor{}
	Goto checkReturnedIndoor if [# TrolleyState == "waitReturnedIndoor" #] else checkResume_idle
	State checkResume_idle{}
	Goto idle 
	
	State waitSonar {
		printCurrentMessage
		emit tStatus : tStatus(stop, $Position)
	}
	Transition tSonar whenTime 1000 -> waitSonar
					  whenEvent trolleyResume -> handleResume
}

QActor storage_glass context ctxwasteservice {
	[#
		var Current = 0.0
		var Max = 100	
	#]
	State init initial {
		emit storageUpdate : storageUpdate(glass, $Current)
	}
	Transition t0 whenRequest storageAsk -> handleReply
				  whenMsg storageDeposit -> doDeposit
	
	State handleReply {
		[# var Left = Max - Current #]
		replyTo storageAsk with storageAt : storageAt($Left)
	}
	Goto init
	
	State doDeposit {
		onMsg(storageDeposit : storageDeposit(QNT)) {
			[# Current += payloadArg(0).toDouble() #]
			emit storageUpdate : storageUpdate(glass, $Current)
		}
		println("\tCurrent glass storage: $Current/$Max")
	}
	Goto init
}

QActor storage_paper context ctxwasteservice {
	[#
		var Current = 0.0
		var Max = 100	
	#]
	State init initial {
		emit storageUpdate : storageUpdate(paper, $Current)
	}
	Transition t0 whenRequest storageAsk -> handleReply
				  whenMsg storageDeposit -> doDeposit
	
	State handleReply {
		[# var Left = Max - Current #]
		replyTo storageAsk with storageAt : storageAt($Left)
	}
	Goto init
	
	State doDeposit {
		onMsg(storageDeposit : storageDeposit(QNT)) {
			[# Current += payloadArg(0).toDouble() #]
			emit storageUpdate : storageUpdate(paper, $Current)
		}
		println("\tCurrent paper storage: $Current/$Max")
	}
	Goto init
}

QActor gui context ctxwasteservice {
	[#
		var LedStatus = "off"
		var Position = 0.0
		var CurrentGlass = 0.0
		var CurrentPaper = 0.0
	#]
	State init initial {
	}
	
	Transition t0 whenEvent tStatus ->  handlePosition
				  whenMsg ledStatus ->  handleLed
				  whenEvent storageUpdate ->  handleStorage
	
	State handleLed {
		onMsg(ledStatus : ledStatus(STATUS)){
			[# LedStatus = payloadArg(0) #]
		}
		println("LedStatus: $LedStatus")
		println("Position: $Position")
		println("CurrentGlass: $CurrentGlass")
		println("CurrentPaper: $CurrentPaper")
	}
	Goto init
	
	State handlePosition {
		onMsg(tStatus : tStatus(_,POS)){
			[# Position = payloadArg(1).toDouble() #]
		}
	}
	Goto init
	
	State handleStorage {
		onMsg(storageUpdate : storageUpdate(MAT, QNT)){
			if [# payloadArg(0) == "glass" #]{
				[# CurrentGlass = payloadArg(1).toDouble() #]
			} else {
				[# CurrentPaper = payloadArg(1).toDouble() #]
			}
		}
		println("LedStatus: $LedStatus")
		println("Position: $Position")
		println("CurrentGlass: $CurrentGlass")
		println("CurrentPaper: $CurrentPaper")
	}
	Goto init
}


QActor led_actor context ctxwasteservice {
	[#
	var Status = "off"
	#]
	State init initial {
		
	}
	
	Transition t0 whenEvent tStatus ->  handleLed
	
	State handleLed {
		onMsg(tStatus : tStatus(STATE, _)){
			if [# payloadArg(0) == "moving" #] {
				[# Status = "blinking" #]
		    } else {
				if [# payloadArg(0) == "home" #]{
					[# Status = "off" #]
				} else {
					[# Status = "on" #]
				}
			}
		}
		forward gui -m ledStatus : ledStatus($Status)
	}
	Goto init
}

QActor sonar context ctxwasteservice {
	[#
	var Status = "continue"
	#]
	State init initial {
		[# var DelayTime : kotlin.Long = kotlin.random.Random.nextLong(9000, 13000) #]
		delayVar DelayTime
		if [# Status == "continue" #]{
			[# Status = "stop" #]
			emit trolleyStop : trolleyStop(_)
			println("\tSONAR: STOP")
		} else {
			[# Status = "continue" #]
			emit trolleyResume : trolleyResume(_)
			println("\tSONAR: RESUME")
		}
	}
	Goto init
}


