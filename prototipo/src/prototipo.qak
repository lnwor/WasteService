System waste_service_prototipo

Request deposit : deposit(MAT, QNT)
Reply allowDeposit : allowDeposit(ALLOW)
Dispatch pickedUp : pickedUp(MAT, QNT)

Request storageAsk : storageAsk(_)
Reply storageAt : storageAt(QNT)
Event storageUpdate : storageUpdate(MAT, QNT)

Reply doneDeposit : doneDeposit(MAT, QNT)

Event tStatus : tStatus(STATE, POSDATA)

Dispatch storageDeposit : storageDeposit(QNT)

Dispatch ledStatus : ledStatus(STATUS)

Event trolleyStop : trolleyStop(_)
Event trolleyResume : trolleyResume(_)

Context ctxwasteservice ip [host="localhost" port=8050]

// Non sar� probabilmente attore nella versione finale, 
// rappresentato cos� per semplicit� nel sistema
QActor camion context ctxwasteservice {
	[#
		var Allowed = false	
	#]
	State init initial {
		[# var DelayTime : kotlin.Long = kotlin.random.Random.nextLong(7000, 10000) #]
		delayVar DelayTime
	}
	Goto req
	
	State req {
		[#
			var Material = if (kotlin.random.Random.nextFloat() > 0.5) "glass" else "paper"
			var Quantity = kotlin.random.Random.nextInt(10, 30)	
		#]
		println ("Truck with $Material in amount $Quantity arrived")
		request requesthandler -m deposit : deposit($Material, $Quantity)
	}
	Transition t1 whenReply allowDeposit -> handleAllowReply
	
	State handleAllowReply {
		onMsg(allowDeposit : allowDeposit(ALLOW)) {
			[# Allowed = payloadArg(0).toBoolean() #]
			
			if [# !Allowed #] {
				println("\tTruck left (denied)")
			}
		}
	}
	Goto init if [# !Allowed #] else waitPickup
	
	State waitPickup {
		
	} 
	Transition t3 whenMsg pickedUp -> finish
	
	State finish {
		println("\tTruck left (done)")
	}
	Goto init
}

QActor requesthandler context ctxwasteservice {
[#
  var TrolleyOut = false
  var OnTrolleyGlass = 0.0
  var OnTrolleyPaper = 0.0
  var CurrentRequestMaterial = ""
  var CurrentRequestQuantity = 0.0
  var CurrentRequestCheck = 0.0
  var FulfillRequestFlag = false
#]  
	State init initial {
		
	}
	Goto idle
	
	State idle {
		printCurrentMessage
	}
	Transition tIdle whenRequest deposit -> askStorage
	
	State askStorage {
		printCurrentMessage
		onMsg( deposit : deposit(MAT, QNT) ){
  			[# 
  				CurrentRequestMaterial = payloadArg(0)
  				CurrentRequestQuantity = payloadArg(1).toDouble()
  				CurrentRequestCheck = CurrentRequestQuantity
			#]
  			
  			if [# CurrentRequestMaterial == "glass" #] {
  				request storage_glass -m storageAsk : storageAsk(_)
  				[# CurrentRequestCheck += OnTrolleyGlass #]
  			} else {
  				request storage_paper -m storageAsk : storageAsk(_)
  				[# CurrentRequestCheck += OnTrolleyPaper #]
  			}
		}
	}
	Transition tAskStorage whenReply storageAt -> handleRequest 
	
	State handleRequest {
		printCurrentMessage
		// Nota: non serve sapere pi�2 da che storage arriva
		onMsg( storageAt : storageAt(QNT) ) {
			[# FulfillRequestFlag = CurrentRequestCheck <= payloadArg(0).toDouble() #]
			replyTo deposit with allowDeposit : allowDeposit($FulfillRequestFlag)
		}
	}
	Goto fulfillRequest if [# FulfillRequestFlag #] else idle 
	
	State fulfillRequest {
		printCurrentMessage
	}
	Goto sendTrolley if [# !TrolleyOut #] else waitForTrolley
	
	State waitForTrolley {
		printCurrentMessage
	}
	Transition tWaitForTrolley whenReply doneDeposit -> sendTrolley 
	
	State sendTrolley {
		printCurrentMessage
		
		forward camion -m pickedUp : pickedUp($CurrentRequestMaterial, $CurrentRequestQuantity)
		request trolley -m deposit : deposit($CurrentRequestMaterial, $CurrentRequestQuantity)
		
		if [# CurrentRequestMaterial == "glass" #] {
			[# OnTrolleyGlass = CurrentRequestQuantity #]
		} else {
			[# OnTrolleyPaper = CurrentRequestQuantity #]
		}
		
		[#
		TrolleyOut = true
		CurrentRequestQuantity = 0.0
		CurrentRequestMaterial = ""
		#]
	}
	Transition tSendTrolley whenReply doneDeposit -> trolleyBack
							whenRequest deposit -> askStorage
							
	State trolleyBack {
		printCurrentMessage
		[# 
			TrolleyOut = false
			OnTrolleyGlass = 0.0
			OnTrolleyPaper = 0.0
		#]
	}
	Goto idle
}

QActor trolley context ctxwasteservice {
	[#
		var CarryType = ""
		var CarryAmount = 0.0
		var Position = 0.0	
		var MaxPos = kotlin.random.Random.nextLong(1, 8)
	#]
	
	State init initial {
		
	}
	Goto idle
	
	State idle {
		printCurrentMessage
		emit tStatus : tStatus(home, $Position)
	}
	Transition tIdle whenRequest deposit -> startMoveDeposit
	
	State startMoveDeposit {
		printCurrentMessage
		
		emit tStatus : tStatus(moving, $Position)
		
		onMsg(deposit: deposit(MAT, QNT)) {
			[# 
  				CarryType = payloadArg(0)
  				CarryAmount = payloadArg(1).toDouble()
			#]
		}
	}
	
	Goto waitDepositEnd
	
	State waitDepositEnd {
		[# Position += 1.0 #]
		printCurrentMessage
		println("\tCurrent Position is: $Position")
		emit tStatus : tStatus(moving, $Position)
		delay 1000
	}
	
	Goto depositEnd if [# Position >= MaxPos #] else waitDepositEnd
	
	State depositEnd {
		printCurrentMessage
		
		emit tStatus : tStatus(stopped, $Position)
		
		if [# CarryType == "glass" #] {
			forward storage_glass -m storageDeposit : storageDeposit($CarryAmount)
		} else {
			forward storage_paper -m storageDeposit : storageDeposit($CarryAmount)
		}
	}
	Goto waitReturnedIndoor
	
	State waitReturnedIndoor {
		[#
			Position -= 1.0	
		#]
		printCurrentMessage
				println("\tGoing back. Current Position is: $Position")
		
		emit tStatus : tStatus(moving, $Position)
		delay 1000
	}
	
	Goto returnedIndoor if [# Position <= 0 #] else waitReturnedIndoor
	
	State returnedIndoor {
		printCurrentMessage
		
		emit tStatus : tStatus(home, $Position)
		
		replyTo deposit with doneDeposit : doneDeposit($CarryType, $CarryAmount)
	}
	Goto idle
}

QActor storage_glass context ctxwasteservice {
	[#
		var Current = 0.0
		var Max = 100	
	#]
	State init initial {
		
	}
	Transition t0 whenRequest storageAsk -> handleReply
				  whenMsg storageDeposit -> doDeposit
	
	State handleReply {
		[# var Left = Max - Current #]
		replyTo storageAsk with storageAt : storageAt($Left)
	}
	Goto init
	
	State doDeposit {
		onMsg(storageDeposit : storageDeposit(QNT)) {
			[# Current += payloadArg(0).toDouble() #]
		}
		println("\tCurrent glass storage: $Current/$Max")
	}
	Goto init
}

QActor storage_paper context ctxwasteservice {
	[#
		var Current = 0.0
		var Max = 100	
	#]
	State init initial {
		
	}
	Transition t0 whenRequest storageAsk -> handleReply
				  whenMsg storageDeposit -> doDeposit
	
	State handleReply {
		[# var Left = Max - Current #]
		replyTo storageAsk with storageAt : storageAt($Left)
	}
	Goto init
	
	State doDeposit {
		onMsg(storageDeposit : storageDeposit(QNT)) {
			[# Current += payloadArg(0).toDouble() #]
		}
		println("\tCurrent paper storage: $Current/$Max")
	}
	Goto init
}

QActor gui context ctxwasteservice {
	[#
		var LedStatus = "off"
		var Position = 0.0
		var CurrentGlass = 0.0
		var CurrentPaper = 0.0
	#]
	State init initial {
	}
	
	Transition t0 whenEvent tStatus ->  handlePosition
				  whenMsg ledStatus ->  handleLed
				  whenEvent storageUpdate ->  handleStorage
	
	State handleLed {
		onMsg(ledStatus : ledStatus(STATUS)){
			[# LedStatus = payloadArg(0) #]
		}
		println("LedStatus: $LedStatus")
		println("Position: $Position")
		println("CurrentGlass: $CurrentGlass")
		println("CurrentPaper: $CurrentPaper")
	}
	Goto init
	
	State handlePosition {
		onMsg(tStatus : tStatus(_,POS)){
			[# Position = payloadArg(1).toDouble() #]
		}
	}
	Goto init
	
	State handleStorage {
		onMsg(storageUpdate : storageUpdate(MAT, QNT)){
			if [# payloadArg(0) == "glass" #]{
				[# CurrentGlass = payloadArg(1).toDouble() #]
			} else {
				[# CurrentPaper = payloadArg(1).toDouble() #]
			}
		}
		println("LedStatus: $LedStatus")
		println("Position: $Position")
		println("CurrentGlass: $CurrentGlass")
		println("CurrentPaper: $CurrentPaper")
	}
	Goto init
}


QActor led_actor context ctxwasteservice {
	[#
	var Status = "off"
	#]
	State init initial {
		
	}
	
	Transition t0 whenEvent tStatus ->  handleLed
	
	State handleLed {
		onMsg(tStatus : tStatus(STATE, _)){
			if [# payloadArg(0) == "moving" #] {
				[# Status = "blinking" #]
		    } else {
				if [# payloadArg(0) == "home" #]{
					[# Status = "off" #]
				} else {
					[# Status = "on" #]
				}
			}
		}
		forward gui -m ledStatus : ledStatus($Status)
	}
	Goto init
}


