System waste_service_prototipo

Request deposit : deposit(MAT, QNT)
Reply allowDeposit : allowDeposit(ALLOW)
Dispatch pickedUp : pickedUp(MAT, QNT)

Request storageAsk : storageAsk(_)
Reply storageAt : storageAt(QNT)
Event storageUpdate : storageUpdate(MAT, QNT)

Reply doneDeposit : doneDeposit(MAT, QNT)

Event tStatus : tStatus(STATE, POSDATA)

Dispatch storageDeposit : storageDeposit(QNT)

Dispatch ledStatus : ledStatus(STATUS)

Event trolleyStop : trolleyStop(_)
Event trolleyResume : trolleyResume(_)

Context ctxwasteservice ip [host="localhost" port=8050]

// Non sarà probabilmente attore nella versione finale, 
// rappresentato così per semplicità nel sistema
QActor camion context ctxwasteservice {
	[#
		var Allowed = false	
	#]
	State init initial {
		[# var DelayTime : kotlin.Long = kotlin.random.Random.nextLong(1000, 6000) #]
		delayVar DelayTime
	}
	Goto req
	
	State req {
		[#
			var Material = if (kotlin.random.Random.nextFloat() > 0.5) "glass" else "paper"
			var Quantity = kotlin.random.Random.nextInt(10, 30)	
		#]
		println ("Truck with $Material in amount $Quantity arrived")
		request requesthandler -m deposit : deposit($Material, $Quantity)
	}
	Transition t1 whenReply allowDeposit -> handleAllowReply
	
	State handleAllowReply {
		onMsg(allowDeposit : allowDeposit(ALLOW)) {
			[# Allowed = payloadArg(0).toBoolean() #]
			
			if [# !Allowed #] {
				println("\tTruck left (denied)")
			}
		}
	}
	Goto init if [# !Allowed #] else waitPickup
	
	State waitPickup {
		
	} 
	Transition t3 whenMsg pickedUp -> finish
	
	State finish {
		println("\tTruck left (done)")
	}
	Goto init
}

QActor requesthandler context ctxwasteservice{
[#
  var TrolleyOut = false
  var OnTrolleyGlass = 0.0
  var OnTrolleyPaper = 0.0
  var CurrentRequestMaterial = ""
  var CurrentRequestQuantity = 0.0
  var CurrentRequestCheck = 0.0
  var FulfillRequestFlag = false
#]  
	State init initial {
		
	}
	Goto idle
	
	State idle {
		printCurrentMessage
	}
	Transition tIdle whenRequest deposit -> askStorage
	
	State askStorage {
		printCurrentMessage
		onMsg( deposit : deposit(MAT, QNT) ){
  			[# 
  				CurrentRequestMaterial = payloadArg(0)
  				CurrentRequestQuantity = payloadArg(1).toDouble()
  				CurrentRequestCheck = CurrentRequestQuantity
			#]
  			
  			if [# CurrentRequestMaterial == "glass" #] {
  				request storage_glass -m storageAsk : storageAsk(_)
  				[# CurrentRequestCheck += OnTrolleyGlass #]
  			} else {
  				request storage_paper -m storageAsk : storageAsk(_)
  				[# CurrentRequestCheck += OnTrolleyPaper #]
  			}
		}
	}
	Transition tAskStorage whenReply storageAt -> handleRequest 
	
	State handleRequest {
		printCurrentMessage
		// Nota: non serve sapere più da che storage arriva
		onMsg( storageAt : storageAt(QNT) ) {
			[# FulfillRequestFlag = CurrentRequestCheck <= payloadArg(0).toDouble() #]
			replyTo deposit with allowDeposit : allowDeposit($FulfillRequestFlag)
		}
	}
	Goto fulfillRequest if [# FulfillRequestFlag #] else idle 
	
	State fulfillRequest {
		printCurrentMessage
	}
	Goto sendTrolley if [# !TrolleyOut #] else waitForTrolley
	
	State waitForTrolley {
		printCurrentMessage
	}
	Transition tWaitForTrolley whenReply doneDeposit -> sendTrolley 
	
	State sendTrolley {
		printCurrentMessage
		
		forward camion -m pickedUp : pickedUp($CurrentRequestMaterial, $CurrentRequestQuantity)
		request trolley -m deposit : deposit($CurrentRequestMaterial, $CurrentRequestQuantity)
		
		if [# CurrentRequestMaterial == "glass" #] {
			[# OnTrolleyGlass = CurrentRequestQuantity #]
		} else {
			[# OnTrolleyPaper = CurrentRequestQuantity #]
		}
		
		[#
		TrolleyOut = true
		CurrentRequestQuantity = 0.0
		CurrentRequestMaterial = ""
		#]
	}
	Transition tSendTrolley whenReply doneDeposit -> trolleyBack
							whenRequest deposit -> askStorage
							
	State trolleyBack {
		printCurrentMessage
		[# 
			TrolleyOut = false
			OnTrolleyGlass = 0.0
			OnTrolleyPaper = 0.0
		#]
	}
	Goto idle
}

QActor trolley context ctxwasteservice {
	[#
		var CarryType = ""
		var CarryAmount = 0.0	
	#]
	
	State init initial {
		
	}
	Goto idle
	
	State idle {
		printCurrentMessage
	}
	Transition tIdle whenRequest deposit -> startMoveDeposit
	
	State startMoveDeposit {
		printCurrentMessage
		onMsg(deposit: deposit(MAT, QNT)) {
			[# 
  				CarryType = payloadArg(0)
  				CarryAmount = payloadArg(1).toDouble()
			#]
		}
			
		[# var DelayTime : kotlin.Long = kotlin.random.Random.nextLong(800, 5000) #]
		delayVar DelayTime
	}
	Goto depositEnd
	
	State depositEnd {
		printCurrentMessage
		
		if [# CarryType == "glass" #] {
			forward storage_glass -m storageDeposit : storageDeposit($CarryAmount)
		} else {
			forward storage_paper -m storageDeposit : storageDeposit($CarryAmount)
		}
	}
	Goto startReturnIndoor
	
	State startReturnIndoor {
		printCurrentMessage
		
		[# var DelayTime : kotlin.Long = kotlin.random.Random.nextLong(800, 5000) #]
		delayVar DelayTime
		
		replyTo deposit with doneDeposit : doneDeposit($CarryType, $CarryAmount)
	}
	Goto idle
}

QActor storage_glass context ctxwasteservice {
	[#
		var Current = 0.0
		var Max = 100	
	#]
	State init initial {
		
	}
	Transition t0 whenRequest storageAsk -> handleReply
				  whenMsg storageDeposit -> doDeposit
	
	State handleReply {
		[# var Left = Max - Current #]
		replyTo storageAsk with storageAt : storageAt($Left)
	}
	Goto init
	
	State doDeposit {
		onMsg(storageDeposit : storageDeposit(QNT)) {
			[# Current += payloadArg(0).toDouble() #]
		}
		println("\tCurrent glass storage: $Current/$Max")
	}
	Goto init
}

QActor storage_paper context ctxwasteservice {
	[#
		var Current = 0.0
		var Max = 100	
	#]
	State init initial {
		
	}
	Transition t0 whenRequest storageAsk -> handleReply
				  whenMsg storageDeposit -> doDeposit
	
	State handleReply {
		[# var Left = Max - Current #]
		replyTo storageAsk with storageAt : storageAt($Left)
	}
	Goto init
	
	State doDeposit {
		onMsg(storageDeposit : storageDeposit(QNT)) {
			[# Current += payloadArg(0).toDouble() #]
		}
		println("\tCurrent paper storage: $Current/$Max")
	}
	Goto init
}